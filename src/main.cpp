////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* libraries */
	#include <avr/io.h>
	#include <avr/interrupt.h>
	#include <avr/wdt.h>
	#include <stdbool.h>
	#include <stdlib.h>
	#include <string.h>
	#include <stdio.h>
	#include "./incl/Clock.h"
	#include "./incl/Lamp.h"
	#include "./incl/SPI.h"
	#include "./incl/MCP2515.h"
	#include "./incl/SimInterface.h"
	#include "./incl/Tone.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* CONSTANTS & SETTINGS */
	// "can_config.h" include is moved to "SimInterface.h" ("can_config.h" is generated by a Python script and has no include guard!)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* CPU clock frequency */
	#define F_CPU 16e6	// not needed in PlatformIO, it is included in platformio.ini

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* C++ features
 * https://www.avrfreaks.net/forum/avr-c-micro-how?name=PNphpBB2&file=viewtopic&t=59453;
 */
	void * operator new(size_t objsize) {return malloc(objsize);}
	void operator delete(void * ptr) {free(ptr);}
	__extension__ typedef int __guard __attribute__((mode (__DI__)));
	extern "C" int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);}
	extern "C" void __cxa_guard_release (__guard *g) {*(char *)g = 1;}
	extern "C" void __cxa_guard_abort (__guard *) {}
	extern "C" void __cxa_pure_virtual(void) {}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* SPI */
	SPI_Core spi_core(SPI_CPOL_SCK_idle_LOW, SPI_CPHA_sample_edege_LEADING, SPI_SCK_prescaler64);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* LEDs with PWM regulation */
	Lamp *bde = new BDE_Lamp; Lamp *mez = new MEZ_Lamp; Lamp *vol = new VOL_Lamp; Lamp *stu = new STU_Lamp; Lamp *vys = new VYS_Lamp;
	
	/* ISR required for fading of LEDs */
	ISR(TIMER1_COMPC_vect) {bde->isr();}
	ISR(TIMER1_COMPB_vect) {mez->isr();}
	ISR(TIMER1_COMPA_vect) {vol->isr();}
	ISR(TIMER2_COMPA_vect) {stu->isr();}
	ISR(TIMER2_COMPB_vect) {vys->isr();}
	
	void brightness_control_init(void)
	/* initializes ADC and enables autotrigger for automatic repeated conversions */
	{
		/* TC1 OVF is used as auto-trigger for ADC */
		TCCR1B |= (1<<CS12) | (1<<CS10);											// TC1 prescaler 1024 >> OVF @ 61.27 Hz
		TIMSK1 |= (1<<TOIE1);														// at TC1 OVF trigger interrupt and load brightness value from ADC

		/* ADC */
		DDRF &= ~(1<<PF0);															// input for pin ADC0
		DIDR0 |= (1<<ADC0D);														// disable digital input buffer for pin ADC0
		ADMUX |= (1<<REFS0);														// U_ref = VCC
		ADMUX |= (1<<ADLAR);														// left adjust conversion result (only 8 MSB is used)
		ADMUX &= ~(1<<MUX4) & ~(1<<MUX3) & ~(1<<MUX2) & ~(1<<MUX1) & ~(1<<MUX0);	// select channel ADC0 (PF0)
		ADCSRB &= ~(1<<MUX5);														// select channel ADC0 (PF0)
		ADCSRA |= (1<<ADATE);														// enable ADC auto-trigger
		ADCSRB |= (1<<ADTS2) | (1<<ADTS1);											// trigger source: TC1 OVF (@ 61.27 Hz)
		ADCSRA |= (1<<ADPS0) | (1<<ADPS1) | (1<<ADPS2);								// ADC clock prescaler 128 >> 16e6/128=125e3Hz
		ADCSRA |= (1<<ADEN);														// enable ADC
		ADCSRA |= (1<<ADSC);														// start the first conversion
	}
	
	/* ISR required for updating set LED brightnes from ADC value */
	ISR(TIMER1_OVF_vect)
	{
		bde->brightness = mez->brightness = vol->brightness = stu->brightness = vys->brightness = ADCH;
	}

	void sigOff(void)
	/* convenience function turning off all LEDs except for the blue one*/
	{
		vol->off(); mez->off(); stu->off(); vys->off();
	}
	
	void showSignal(uint8_t signal_code)
	/* convenience function that turns on the appropriate LED of signal repeater based on given signal code*/
	{
		switch (signal_code)
		{
			case 0: vys->off(); stu->off(); vol->off(); mez->off(); break;
			case 1: vys->off(); stu->on(); vol->off(); mez->off(); break;
			case 2: vys->off(); stu->off(); vol->off(); mez->on(); break;
			case 3: vys->on(); stu->off(); vol->off(); mez->off(); break;
			case 4: vys->off(); stu->off(); vol->on(); mez->off(); break;
		}
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* time */
	Clock clock;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* MCP2515 CAN controller */
	SPI_Device can_device = SPI_Device((uint16_t*)&PORTL, (uint16_t*)&DDRL, PL0, &spi_core);		// SPI interface for CAN controller - SS signal on PL0 (port L, pin 0)
	MCP2515 can_controller = MCP2515(&can_device);
	
	//void mcp_registers(void)
	//{
		//uint8_t tmp;
		//can_device.select();
		//can_device.transmit(0b00000011);
		//for (uint8_t i = 0; i < 128; i++)
		//{
			//tmp = can_device.transmit(0x00);
		//}
			//
		//can_device.deselect();
	//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Communication with the simulator */
	SimInterface sim = SimInterface(&can_controller, &clock);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Tone generation */
	Tone tone;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* reset MCU using watchdog */
void reset(void)
{
	wdt_enable(WDTO_15MS);													// enable watchdog-timer
	asm("NOP");
	while (1);																// wait for the WDT to time-out and reset the MCU
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* LS90 */

	#define V_KONSTR 140
	#define V_CAUTION 120
	#define V_SLOW 40
	
	enum LS90Status:uint8_t
	{
		LS_PWRDOWN, LS_OFF, LS_START, LS_INHIBIT, LS_NO_CODE, LS_RESTRICTED, LS_PERMISIVE, LS_TRIP
	};
	
	timestamp random_delay(uint16_t max)
	{
		return max * (clock.millis() % 100) / 100;
	}
	
	template <class T>
	T max(T a, T b) {if (a > b) return a; else return b;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* main definition */
	int main(void)
	{	
		timestamp mark = clock.millis(), vigilance_button_ok = clock.millis();// vigilance_pressed = clock.millis();
		timestamp vigilance_acknowledged = clock.millis();
		timestamp emp_active = clock.millis(), limit = clock.millis();
		timestamp delta = 0, last_integration = clock.millis();
		int16_t distance = 0; // in mm; calculated only when travelling with the wrong direction selected
		timestamp aux = clock.millis();
		
		/* general init */
		sei();
		clock.init();
		spi_core.init();
		sim.init();
		tone.init();
		
		// LS 90
		bde->init(5); mez->init(5); vol->init(5); stu->init(5); vys->init(5); // argument is the number of PWM periods needed to fade in/out
		brightness_control_init();
		LS90Status status = LS_OFF, prev_status = LS_OFF;
		bool speed_switch = false, pressure_switch = false, pwr_up_blocked = true;
		sim.ep_valve.value = true;
		sim.ls_indicator.value = 0;

		while (1) // main loop
		{
			////////////////////////////////////////////////
			/* actions independent of the state of simulation */
			////////////////////////////////////////////////
			/* read and update input sim variables, send the output ones */
			sim.loop();
			/* adjust volume, if change in input variable is detected */
			if (sim.volume.value != sim.volume.previous)	// new value for volume was received
			{
				tone.volume(sim.volume.value);				// change volume
				sim.volume.previous = sim.volume.value;		// save new value as 'previous' - used for detecting changes
			}
			/* calculate simulation time step */
			if (clock.millis() > last_integration + 10) delta = clock.millis() - last_integration; else delta = 0;
			//delta = clock.millis() - last_integration; last_integration = clock.millis();
			/* always check, if BATTERY is ON, if not, go immediately from any state to PWRDOWN state */
			if (sim.battery.value == false)
			{
				if (clock.millis() > aux + 200)
					status = LS_PWRDOWN;
			} else
			{
				aux = clock.millis();
			}
			
			////////////////////////////////////////////////
			/* actions performed if LS is in one of the operation states */
			////////////////////////////////////////////////
			if (status == LS_INHIBIT || status == LS_NO_CODE || status == LS_RESTRICTED || status == LS_PERMISIVE)
			{
				sim.ls_indicator.value = false;			// LS_INDICATOR is always OFF in these states
				/* EMP last active time recording */
				if (sim.emp.value == true && status == LS_NO_CODE)
					emp_active = clock.millis();				// record the last time EMP was active
				/* switching LS90 OFF from operation by LS_SWITCH */
				if (sim.ls_switch.value != 2)		// LS_SWITCH no longer in OPERATION position
				{
					status = (sim.ls_switch.value == 0) ? (LS_OFF) : (LS_START);		// go to appropriate state based on position of LS_SWITCH
					continue;
				}
				/* decide between NO_CODE, RESTRICTED or PERMISIVE state based on SIGNAL_CODE and SPEED values */
				prev_status = status;				// record previous status (used for change detection in RESTRICTED state)
				switch (sim.signal_code.value)
				{
					// for 
					case 0: status = LS_NO_CODE; break;
					case 1: status = LS_RESTRICTED; break;
					case 2: status = (sim.speed.value > V_SLOW * CANMULT_SPEED) ? (LS_RESTRICTED) : (LS_PERMISIVE); break;
					case 3: status = (sim.speed.value > V_CAUTION * CANMULT_SPEED) ? (LS_RESTRICTED) : (LS_PERMISIVE); break;
					case 4: status = (sim.speed.value > V_KONSTR * CANMULT_SPEED) ? (LS_RESTRICTED) : (LS_PERMISIVE); break;
				}
				/* display signal code */
				if (sim.direction_leaver.value != -1)				// unless DIRECTION_LEAVER is in REVERSE position
				{
					showSignal(sim.signal_code.value);		// display received signal code
					} else {
					sigOff();
					status = LS_NO_CODE;
				}
				/* check conditions for automatic system INHIBIT */
				if (pressure_switch)		// pressure switch engaged
				{
					// pressure switch disengages if BRAKE_CYLINDER_PRESSURE is lower than 0.5 bar
					if (sim.brake_cylinder_pressure.value <= 0.5 * CANMULT_BRAKE_CYLINDER_PRESSURE)
						pressure_switch = false;
				}
				else						// pressure switch disengaged
				{
					// pressure switch engages if BRAKE_CYLINDER_PRESSURE is greater than 1.5 bar
					if (sim.brake_cylinder_pressure.value >= 1.5 * CANMULT_BRAKE_CYLINDER_PRESSURE)
						pressure_switch = true;
				}
				if (speed_switch)			// speed switch engaged
				{
					if (sim.speed.value >= 15 * CANMULT_SPEED)
						speed_switch = false;
				}
				else						// speed switch engaged
				{
					if (sim.speed.value < 10 * CANMULT_SPEED) speed_switch = true;}
				if (speed_switch && pressure_switch)		// if both switches are active, go to INHIBIT state
					status = LS_INHIBIT;
				/* detect incorrect direction of movement, measure distance, trigger TRIP state if in operation */
				if (sim.speed.value == 0)			// stationary
					distance = 0;			// direction check OK
				else								// moving
				{
					if (sim.speed.value * sim.direction_leaver.value <= 0)	// INCORRECT position of direction leaver
					{
						distance += delta * sim.speed.value / CANMULT_SPEED / 36 * 10;	// accumulate distance
						if (abs(distance) >= 15000)
							status = LS_TRIP;					// over 15 m traveled with incorrect configuration -> TRIP
					}
					else													// CORRECT position of driving leaver
					{
						distance = 0;		// direction check OK
					}
				}
			}
			
			////////////////////////////////////////////////
			/* actions performed if LS is in none of the operation states */
			/* TRIP state is not handled in this section */
			////////////////////////////////////////////////
			if (status == LS_PWRDOWN || status == LS_OFF || status == LS_START)
			{
				bde->off();
				sigOff();
			}
			
			////////////////////////////////////////////////
			/* different behavior for all the states */
			////////////////////////////////////////////////
			switch (status)
			{
				case LS_PWRDOWN:
				// If loco battery is OFF, EPV is not energized and is open, ATP does nothing.
				// If battery is switched ON, check if LS_SWITCH is in OFF position and go to OFF state,
				// otherwise stay in POWERDOWN state.
					sim.ls_indicator.value = 0;		// LS_INDICATOR is always OFF in this state
					sim.ep_valve.value = true;		// EPV stays always open in this state
					
					if (sim.battery.value == true)	// battery is ON
					{
						if (sim.ls_switch.value != 0)	// SWITCH not in OFF position
						{
							pwr_up_blocked = true;		// remain powered down, and block PWR-UP until battery is reset
						} else							// SWITCH is in OFF position
						{
							if (!pwr_up_blocked) status = LS_OFF;
						} // SWITCH IS in OFF position, EPV opens and LS goes to OFF status
					} else // battery is OFF
					{
						pwr_up_blocked = false;
						// remain in POWERDOWN state
					}
					break;
				
				case LS_OFF:
				// ATP powered-on, in OFF state.
				// Detect, when LS_SWITCH is moved to START position, start measuring time and go to START state
				// if LS_SWITCH is moved to the OPERATION position now without waiting for the green light on LS_INDICATOR,
				// go to TRIP state
					sim.ls_indicator.value = 0;		// LS_INDICATOR is always OFF in this state
					sim.ep_valve.value = false;		// EPV is always closed in this state
					switch(sim.ls_switch.value)
					{
						case 0:
						// LS_SWITCH remains in OFF position
							break;
						case 1:
						// LS_SWITCH was moved to the START position now
							sim.ls_indicator.mark = clock.millis();		// record time of transition
							limit = random_delay(500);					// generate random delay needed for simulation of internal behavior
							status = LS_START;							// go to START state
							break;
						case 2:
						// LS_SWITCH was moved to OPERATION position without waiting for the green indication
							status = LS_TRIP;
							break;
					}
					break;
				
				case LS_START:
				// ATP powered, START sequence in progress
				// Wait until random generated delay from entering START state has elapsed
				// then evaluate, if start conditions are met (direct brake applied, speed = 0).
				// Immediately after entering START state, set LS_INDICATOR to 1 (red), if start-conditions
				// are satisfied (after delay), switch it to 2 (green)
				// Monitor position of LS_SWITCH. If it goes back to OFF, change state to OFF.
				// If LS_SWITCH is set to OPERATION position, before green indication was displayed, go to TRIP.
				// If is was set to OPERATION position, before green indication, go to INHIBIT state.
					sim.ep_valve.value = false;		// EPV is always closed in this state
					switch(sim.ls_switch.value)
					{
						case 0:		// switched back to OFF
							status = LS_OFF;
							break;
						
						case 1:		// remaining in START state
						/* test START requirements - tested only after minimal time from entering START sequence has passed */
							if (clock.millis() > sim.ls_indicator.mark + limit)		// delay from entering START has passed
							{
								if ((sim.brake_cylinder_pressure.value >= 1.5 * CANMULT_BRAKE_CYLINDER_PRESSURE) && (sim.speed.value == 0))
									sim.ls_indicator.value = 2;
								else /* requirements not met */
									sim.ls_indicator.value = 1;
							} else /* time not yet passed */
							{
								sim.ls_indicator.value = 1;
							}
							break;
						
						case 2:		// switched to OPERATION position - evaluate, whether start-up procedure was completed successfully
							if (sim.ls_indicator.value == 2)	// green indication was given
							{
								status = LS_INHIBIT;			// go to operation (INHIBIT state)
							}
							else								// no green indication
							{
								{status = LS_TRIP;}		 // go to TRIP
							}
							break;
					}
					break;
				
				case LS_TRIP:
				// ATP has intervened
				// EPV is opened and LS_INDICATOR is OFF
				// (LS_INDICATOR turns of when TRIP state was entered after switching LS_SWITCH to OPERATION position
				// without waiting for green indication)
					tone.off(); bde->off(); sigOff();		// turn off all indications
					sim.ep_valve.value = true;				// EPV is always open in TRIP state
					sim.ls_indicator.value = 0;				// LS_INDICATOR is always off in TRIP state
					/* test if train has come to a stop and LS90 was switched of by LS_SWITCH after entering TRIP state */
					if (sim.speed.value == 0 && sim.ls_switch.value == 0)
						status = LS_OFF;					// exit TRIP state and begin reinitialization
					break;
				
				case LS_INHIBIT:
				// ATP is in automatic inhibit state
				// EPV is closed, LS_INDICATOR off and blue light on
				// if VIG button is pressed, TONE is on
					bde->on();		// blue light is always on
					if (sim.vigilance_button.value == 1)	// if VIG button is pressed
						tone.on();
					else
						tone.off();
					break;
				
				case LS_PERMISIVE:
				// permissive signal code is received
				// turn off blue light, but turn it back on when VIG button is pressed, while also turning on the TONE
					if (sim.vigilance_button.value == 1)
					{
						tone.on(); bde->on();
					} else
					{
						tone.off(); bde->off();
					}
					break;
					
				case LS_RESTRICTED:
				case LS_NO_CODE:
					if (status != prev_status)
					{
						prev_status = status;
						mark = clock.millis();
					}
				
					if (sim.vigilance_button.value != sim.vigilance_button.previous)	// vigilance button state changed
					{
						sim.vigilance_button.previous = sim.vigilance_button.value;		// update stored 'previous' value (for change detection)
						if (sim.vigilance_button.value == 1)									// button pressed
							sim.vigilance_button.mark = clock.millis();								// start measuring time
						else																	// button released
						{
							if (clock.millis() > sim.vigilance_button.mark + 200)				// button was pressed for at least 200 ms
							{
								if (clock.millis() > vigilance_button_ok + 4000)		// BDE is OFF (4 s has passed since last confirmation)
									vigilance_button_ok = clock.millis();			// record valid vigilance confirmation
							}
						}
					}
					
					limit = max(mark + 5500, vigilance_button_ok + 11000);
					if (status == LS_NO_CODE && vigilance_button_ok > mark)
					{
						limit = max(limit, emp_active + 11000);
						vigilance_acknowledged = max(vigilance_button_ok, emp_active);
					} else {
						vigilance_acknowledged = vigilance_button_ok;
					}
					
					if (clock.millis() >= limit + 4000)
						status = LS_TRIP;
					else if (clock.millis() >= limit) {tone.on(); bde->off();}
					else if (clock.millis() > (vigilance_acknowledged) + 4000) {tone.off(); bde->off();}
					else {bde->on(); if (sim.vigilance_button.value == 1) tone.on(); else tone.off();}
					break;
			}
		}
	}